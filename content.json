{"meta":{"title":"pluto","subtitle":"","description":"","author":"John Doe","url":"https://plutokang.github.io","root":"/"},"pages":[{"title":"关于pluto","date":"2023-03-23T09:44:56.567Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"about/index.html","permalink":"https://plutokang.github.io/about/index.html","excerpt":"","text":"pluto，就是一个写不出代码并且还想着写完作业的菜鸡罢了。从来不喜欢学习，但是被困在学习的苦海里。123"},{"title":"archives","date":"2020-07-18T05:10:34.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"archives/index.html","permalink":"https://plutokang.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-30T03:41:17.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"categories/index.html","permalink":"https://plutokang.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-30T14:45:09.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"contact/index.html","permalink":"https://plutokang.github.io/contact/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-30T14:40:51.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"friends/index.html","permalink":"https://plutokang.github.io/friends/index.html","excerpt":"","text":""},{"title":"图库","date":"2023-01-04T03:46:37.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"gallery/index.html","permalink":"https://plutokang.github.io/gallery/index.html","excerpt":"","text":"{ % gallery % }{ % endgallery % }"},{"title":"","date":"2016-12-31T10:09:56.000Z","updated":"2016-12-31T10:09:56.000Z","comments":false,"path":"history/index.html","permalink":"https://plutokang.github.io/history/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-05-28T03:09:14.000Z","updated":"2023-03-23T09:44:56.567Z","comments":false,"path":"link/index.html","permalink":"https://plutokang.github.io/link/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-24T09:37:05.000Z","updated":"2017-02-24T09:37:05.000Z","comments":false,"path":"tags/index.html","permalink":"https://plutokang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"os-lab2","slug":"os-lab2","date":"2023-03-23T09:41:39.000Z","updated":"2023-03-23T09:44:56.567Z","comments":true,"path":"os-lab2.html","link":"","permalink":"https://plutokang.github.io/os-lab2.html","excerpt":"","text":"一点点感想首先，我们可以看到整个mos操作系统是一个逻辑非常完整的体系结构，通过一些巧妙的手段，实现了我以前的一些困惑，我对这个操作系统的编写者确实怀有很高的崇敬。其次，我们的助教确实辛苦，也很值得尊敬，在我写lab2过程中提供了很多帮助。最后对于os课程组有一点点抱怨，第一，在这个操作系统中，代码风格非常简陋，甚至出现了page2kva这样让人摸不着头脑的函数名，其次，虽然我们的助教认真负责，但是在指导书中有一些东西确实很难以领悟，不得不通过其他方式进行学习和揣摩。 lab2概述lab2中，主要进行了对操作系统的页式内存管理和tlb的代码实现，主要难点还是在链表宏的编写和页式内存管理的理解，接下来我会主要根据这两个方面编写博客。 exerciseexercise2.1exercise2.1内容不难，但是主要有两点第一是这里遗漏了一个条件，根据往年的指导书，我们可以在include&#x2F;mmu.h中找到BY2PG(byte to page)和PGSHIFT(12)这两个条件，表明页的大小是4kb第二个是，和往届代码不同，这里通过从外设读取硬件可用内存大小，往届是直接给出，但是从结果上看，都是64MB代码如下 12345678void mips_detect_memory() &#123; /* Step 1: Initialize memsize. */ memsize = *(volatile u_int *)(KSEG1 | DEV_MP_ADDRESS | DEV_MP_MEMORY); /* Step 2: Calculate the corresponding &#x27;npage&#x27; value. */ /* Exercise 2.1: Your code here. */ npage = memsize &gt;&gt; PGSHIFT; printk(&quot;Memory size: %lu KiB, number of pages: %lu\\n&quot;, memsize / 1024, npage); &#125; exercise2.22.2到2.5的实验中都是实现链表法管理内存的，页是存储在kseg0上面的，而结构体Page是页控制块，页控制块构成了页的空闲链表，通过对于链控制块的操分配和回收实现页的分配和回收exercise2.2主要是对这个链表的理解，我认为这个链表的功能确实强大，构建思维确实巧妙。首先我们要知道执行宏的过程，对于宏的翻译，可以理解成直接将文本进行替换。其次，LIST_ENTRY这个结构体进行一下更明确的阐述。我们不妨设Page是一个结构体(在这里使用这个是因为接下来的内容需要用到，但是其他结构体也可以使用),在这个结构体中，LIST_ENTRY是其中的一个内容，在LIST_ENTRY中le_next指向下一个链表中下一个Page，而le_prev指向的是上一个Page结构体中的LIST_ENTRY中的le_next。这样根据指导书上的图片就不难理解了。代码如下： 12345678#define LIST_INSERT_AFTER(listelm, elm, field) \\ do &#123; \\ LIST_NEXT((elm),field) = LIST_NEXT((listelm),field); \\ if ( LIST_NEXT((listelm),field) != NULL ) \\ (LIST_NEXT((elm),field))-&gt;field.le_prev = &amp;LIST_NEXT((elm),field); \\ LIST_NEXT((listelm),field) = elm; \\ (elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm),field); \\ &#125; while (0) tips: 因为是宏编写，所以必须要使用do while(0) ，不必要的括号以及行尾的\\，至于原因，可以参考预习教程中的c语言拾遗一节 建议将include&#x2F;queue.h中的所有有关LIST的函数全部看一下实现过程，对之后的实验特别有帮助 exercise2.3接下来的所有内容中，我们需要搞清楚进行操作的是物理地址还是虚拟地址，否则在进行后续实验中将出现非常大的困扰首先我们要明确一个问题，页是存储在kseg0段的，页的分配是从低地址向高地址一页一页分配，而如果我们阅读过alloc的代码就可以发现，freemem的地址是随着分配的页数而增加的。换句话说，freemem之下是分配过的页面，是正在使用的，freemem之上的页面是未使用过的，可以被分配的。但是我们需要知道freemem之下有多少内存空间，fremem之上有多少内存空间。这个时候用freemem减去kseg0地址(将高位清零)，得到的就是freemem之下内存数，这个正好对应freemem物理地址，可以通过PADDR来实现。至于上限是什么可以通过2.1中的npage来记录。注意，不要忘记将freemem进行页内存的对齐。代码如下： 123456789101112131415161718192021void page_init(void) &#123; /* Step 1: Initialize page_free_list. */ /* Hint: Use macro `LIST_INIT` defined in include/queue.h. */ /* Exercise 2.3: Your code here. (1/4) */ LIST_INIT(&amp;page_free_list); /* Step 2: Align `freemem` up to multiple of BY2PG. */ /* Exercise 2.3: Your code here. (2/4) */ ROUND(freemem,BY2PG); int i =PADDR(freemem) / BY2PG-1; for( i ; i &gt;= 0;i--) (*(pages + i)).pp_ref = 1; /* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */ /* Exercise 2.3: Your code here. (3/4) */ for(i = PADDR(freemem) / BY2PG ;i &lt; npage;i++) &#123; (*(pages + i)).pp_ref = 0; LIST_INSERT_HEAD(&amp;page_free_list,pages + i,pp_link); &#125; /* Step 4: Mark the other memory as free. */ /* Exercise 2.3: Your code here. (4/4) */ &#125; exercise2.4首先我先列一下有些可能使用到的奇奇怪怪函数名的含义，这些函数之后可能用得上 page2kva page to kernel virtual address page2pa page to phsical address pa2ka physical address to kernel address ka2pa kernel address to physical address分配页的核心思路是，判断链表是否为空，将链表头的页控制块对应的页清空，给new分配页地址，将链表中头元素移除。如果能正确理解页控制块和页的关系，这个不是很难。代码如下：123456789101112131415int page_alloc(struct Page **new) &#123; /* Step 1: Get a page from free memory. If fails, return the error code.*/ struct Page *pp; /* Exercise 2.4: Your code here. (1/2) */ if(LIST_EMPTY((&amp;page_free_list))) return -E_NO_MEM; /* Step 2: Initialize this page with zero. * Hint: use `memset`. */ /* Exercise 2.4: Your code here. (2/2) */ pp = LIST_FIRST((&amp;page_free_list)); memset((void *)(page2kva(pp)),0,BY2PG); LIST_REMOVE(pp, pp_link); *new = pp; return 0; &#125; exercise2.5这道题目也很简单，直接上代码吧 1234567void page_free(struct Page *pp) &#123; assert(pp-&gt;pp_ref == 0); /* Just insert it into &#x27;page_free_list&#x27;. */ /* Exercise 2.5: Your code here. */ if (pp-&gt;pp_ref == 0) LIST_INSERT_HEAD(&amp;page_free_list,pp,pp_link); &#125; 其实if判断条件没什么太大用处，但是为了更加保险一点，就写了。 exercise2.6真正比较难的地方开始了其实exercise2.6和exercise2.7真正的核心就在于指导书的图2.4。简单补充一下指导书上面没有讲到的事情。这里感谢一下孙海龙老师，课上教怎么从虚拟地址映射到实际物理地址，我感觉如果他提前讲过或者我晚写完几天作业，就可以节省我三四个小时甚至更多的时间。首先有一个基址寄存器，存的就是一级页表的最低位地址，程序中就是pgdir。首先我们要在一级页表中找到一级页表的对应的项，就是pgdir+PDX(va)，从这个地址中我们获取了对应的二级页表基地址。此时，我们图上出现了一个perm。我之前有个疑问，就是怎么控制某一个页是否有效，是否可读可写。这里进行了解释，和二级页表基地址取出来的，还有权限位，由于二级页表同样是页式存储，所以二级页表也有权限位。二级页表的基地址只占前20位，后12位肯定为0，用后20位作为权限位。所以用在include&#x2F;mmu.h有PTE_V,PTED等，不难发现，这些都是2的幂次方，也就是说，反映在二进制上就是某一位是1，其他都是0，判断能否对一个页进行某种操作时，就用对应的操作和perm做与运算即可。比如我们判断某一页是不是可用，需要进行PTBase &amp; PTE_V，如果得出的结果是1，就是可用，0就是不可用。同样，我们在插入一个二级页表中，也需要更改权限位，比如使某一个页面可用，就需要进行PTBase | PTE_V.图中由PTBase | perm 引向 PTBase | PTX | va的意思并不是通过PTBase | perm通过转换得到PTBase | PTX | va，而是通过PTBase得到PTBase | PTX | va，perm只不过是权限位基本原理是这样的，先看代码 123456789101112131415161718192021222324252627282930313233343536373839static int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte) &#123; Pde *pgdir_entryp; struct Page *pp; pgdir_entryp = pgdir + PDX(va); Pte *PTBase; /*一级页表项中存储的是二级页表的物理基地址，首先对应到kseg0上，在对应到·虚拟地址*/ /*PTE_ADDR是将第十二位清空*/ PTBase = KADDR(PTE_ADDR(*pgdir_entryp)); /*判断一级页表项中二级页表基地址是否可用*/ if(!(*pgdir_entryp &amp; PTE_V)) &#123; if(create) &#123; if(page_alloc(&amp;pp) == -E_NO_MEM) &#123; *ppte = NULL; return -E_NO_MEM; &#125; else &#123; pp-&gt;pp_ref++; /*二级页面基地址赋值为pp的地址并且将其转换为虚拟地址*/ PTBase =page2pa(pp); *pgdir_entryp = PTBase; PTBase = KADDR(*pgdir_entryp); /*设置权限位*/ *pgdir_entryp = (*pgdir_entryp) | PTE_D | PTE_V; &#125; &#125; else &#123; *ppte = NULL; return -E_NO_MEM; &#125; &#125; /*找到二级页表对应的页的入口*/ *ppte = PTBase + PTX(va); return 0;&#125;b pgdir_walk这个写的确实很巧妙。这个实现了两个功能，查找存储va对应页面的二级页表的项，如果存在二级页表，就将ppte赋值项地址，如果不存在二级页表或这个二级页表不可用且create是1，就创建二级页表在找到项，将ppte赋值项地址，如果如果不存在二级页表或这个二级页表不可用且create是0，就返回错误信息。具体顺序看代码注释。能力还是不太够，如果哪里有不明白的地方，就私信联系我吧。 exercise2.7如果2.6能够理解明白2.7就不是很难的一个过程了。当我们二级页表中某一项为空或者需要将二级页表某一项置换成为近期所需要的页面时，就需要pgdir_insert，这个函数是将pp和va建立起一一映射。在这个过程中，需要考虑几个问题： va对应的那一页在二级页表中是否为空 如果空怎么办 不空的话有两种情况：里面的就是pp，里面的不是pp 如果是pp进行什么操作 如果不是pp进行什么操作根据这些问题就能理解这段代码了：12345678910111213141516171819202122232425int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm) &#123; Pte *pte; pgdir_walk(pgdir, va, 0, &amp;pte);//查看va对应一页是不是空 if (pte &amp;&amp; (*pte &amp; PTE_V)) &#123; //不空 /*不是pp 就将这一页从页表中移除，之后当作空来处理*/ if (pa2page(*pte) != pp) &#123; page_remove(pgdir, asid, va); &#125; /*如果是pp，就先将pp这一页从tlb中取出，然后更改权限位 这一个判断是用来更改权限位的，就算直接返回，测评也不会出错，但是不建议，因为有用*/ else &#123; tlb_invalidate(asid, va); *pte = page2pa(pp) | perm | PTE_V; return 0; &#125; &#125; /*如果空*/ tlb_invalidate(asid,va);//将va这一页从tlb中清理掉 if(pgdir_walk(pgdir,va,1,&amp;pte) == -E_NO_MEM) return -E_NO_MEM; //给pte中赋值 *pte = (page2pa(pp) | perm | PTE_V); pp-&gt;pp_ref++; return 0&#125; exercise2.82.8到2.10都是对于tlb的操作，这一块不是很难的部分2.8很简单，直接添加两行代码，不做解释，直接看代码： 1234567891011121314151617LEAF(tlb_out) .set noreorder mfc0 t0, CP0_ENTRYHI mtc0 a0, CP0_ENTRYHI nop tlbp nop mfc0 t1, CP0_INDEX .set reorder bltz t1, NO_SUCH_ENTRY .set noreorder mtc0 zero, CP0_ENTRYHI mtc0 zero, CP0_ENTRYLO0 nop tlbwi nop .set reorder exercise2.92.9其实也不是很难。这个函数的作用就是在va分配对应页面。至于pgdir_lookup说简单一点，就是找到va对应的页，并且将pte赋值为入口值。而passive_alloc核心就是两个，page_alloc(p)和pgdir_insert，同样这两个也是_do_tlb_refill的核心。虽然这么说，但是我还还是觉得这个函数名实在起的有点不太合适，毕竟不是tlb的充填。tips：建议看看pgdir_lookup的源代码代码如下： 123456789Pte _do_tlb_refill(u_long va, u_int asid) &#123; Pte *pte; while(page_lookup(cur_pgdir,va,&amp;pte) == NULL) &#123; passive_alloc(va,cur_pgdir,asid); &#125; return *pte; &#125; exercise2.10这个函数才是对tlb的充填！！！！代码就一行，不说了，具体过程看指导书代码如下： 1234567891011121314NESTED(do_tlb_refill, 0, zero) mfc0 a0, CP0_BADVADDR mfc0 a1, CP0_ENTRYHI srl a1, a1, 6 andi a1, a1, 0b111111 sw ra, tlb_refill_ra jal _do_tlb_refill lw ra, tlb_refill_ra mtc0 v0, CP0_ENTRYLO0 nop tlbwr jr ra END(do_tlb_refill) 总结一下完结撒花！！！！！！lab2相对于lab1更难，代码量更大，也更不好理解，到现在我也有很多不理解的地方，用了四天时间才写完，又用了四天时间写完（虽然能早点，但是回宿舍以后好多时间都在看狂飙），不过终于更新完了。但是由于本人是个菜菜，有些东西写的不太清楚，并且有错误，如果有不清楚或者不合适，不正确的地方就找我联系","categories":[],"tags":[]},{"title":"os-lab1","slug":"os-lab1","date":"2023-03-09T12:16:04.000Z","updated":"2023-03-23T09:44:56.567Z","comments":true,"path":"os-lab1.html","link":"","permalink":"https://plutokang.github.io/os-lab1.html","excerpt":"","text":"lab1概述在BUAA 操作系统的实验课上，主要通过GXemul来模拟裸机，从而实现编写一个mos操作系统 相比于前几届的实验课，就lab1而言，要简单一些，同时可以将前几届的mos操作系统作为参考，可以起到不错的提示和debug作用 在lab1中，从内核转移到内存开始实现，主要实现几个功能 补全readelf文件，实现readelf 将内核加载到正确位置，不全kernel.lds代码 完成_start函数，找到mos内核启动入口 完成printk.c函数，实现输出功能 exerciseexercise 1.1这个练习本质上不难，只要分辨概念足可以做出题目。但是由于在操作系统课上，我们只是简单了解了elf文件的组成内容，但是并没有介绍节头表和段头表的内容，并且我认为节头表入口和段头表入口这两个概念在中文中不是经常被提及，所以容易产生问题 首先我们来了解节头表和段头表的概念和组成。节头表(section header table) 本质上是由若干个节头表(section header)组成，节头表不是一个结构体，相当于是节头表入口集合。节头表入口是一个结构体，在结构体中包含节头表入口的大小，和相对于elf表头的偏移量还有该节位置等信息，相当于是一个 指向每个节(section)的指针。并且在elf头表中，含有节头表入口的的大小，每个节头表入口大小是相同的，这是因为节头表入口时大小固定的结构体，如果想求出每个节头表入口的位置，可以通过offset(elf header) + offset-to-elfheader(section header table) + size(section header) * n来求 这是这道题的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;elf.h&quot;#include &lt;stdio.h&gt;/* Overview: * Check whether specified buffer is valid ELF data. * * Pre-Condition: * The memory within [binary, binary+size) must be valid to read. * * Post-Condition: * Returns 0 if &#x27;binary&#x27; isn&#x27;t an ELF, otherwise returns 1. */int is_elf_format(const void *binary, size_t size) &#123; Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary; return size &gt;= sizeof(Elf32_Ehdr) &amp;&amp; ehdr-&gt;e_ident[EI_MAG0] == ELFMAG0 &amp;&amp; ehdr-&gt;e_ident[EI_MAG1] == ELFMAG1 &amp;&amp; ehdr-&gt;e_ident[EI_MAG2] == ELFMAG2 &amp;&amp; ehdr-&gt;e_ident[EI_MAG3] == ELFMAG3;&#125;/* Overview: * Parse the sections from an ELF binary. * * Pre-Condition: * The memory within [binary, binary+size) must be valid to read. * * Post-Condition: * Return 0 if success. Otherwise return &lt; 0. * If success, output the address of every section in ELF. */int readelf(const void *binary, size_t size) &#123; Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary; // Check whether `binary` is a ELF file. if (!is_elf_format(binary, size)) &#123; fputs(&quot;not an elf file\\n&quot;, stderr); return -1; &#125; // Get the address of the section table, the number of section headers and the size of a // section header. const void *sh_table; Elf32_Half sh_entry_count; Elf32_Half sh_entry_size; /* Exercise 1.1: Your code here. (1/2) */ sh_table = binary + ehdr-&gt;e_shoff; sh_entry_count = ehdr-&gt;e_shnum; sh_entry_size = ehdr-&gt;e_shentsize; // For each section header, output its index and the section address. // The index should start from 0. for (int i = 0; i &lt; sh_entry_count; i++) &#123; const Elf32_Shdr *shdr; shdr = (Elf32_Shdr *)sh_table; unsigned int addr; /* Exercise 1.1: Your code here. (2/2) */ addr = shdr-&gt;sh_addr; sh_table += sh_entry_size; printf(&quot;%d:0x%x\\n&quot;, i, addr); &#125; return 0;&#125; 注意：在使用结构体的指针时，要是用-&gt;而不是. exercise 1.2这道题其实不是很难，首先要找到kernel所存的位置即可，由于在cache为启动时，是能使用kseg0作为内核代码存放位置，并且在0x80000000-0x80010000位置存放的是exception entry，就可以明白，代码段和数据段被存储在0x80010000以上就好其实要明白在linker script中，’.’是一个定位计数器，是可以改变自身位置的。 这道题比较容易出现问题的点就是，一定要注意linker script的格式，等号两边以及冒号两边都有空格 代码如下： 123456789101112131415161718192021222324252627282930/* * Set the architecture to mips. */OUTPUT_ARCH(mips)/* * Set the ENTRY point of the program to _start. */ENTRY(_start)SECTIONS &#123; /* Exercise 3.10: Your code here. */ /* fill in the correct address of the key sections: text, data, bss. */ /* Exercise 1.2: Your code here. */ . = 0x80010000; .text : &#123; *(.text) &#125; .data : &#123; *(.data) &#125; .bss : &#123; *(.bss) &#125; bss_end = .; . = 0x80400000; end = . ;&#125; 注意一点就是，在上一届的操作系统实验课中，还为execption entry分配了地址空间，同时，还未.sdata段分配了空间。 exercise1.3exercise1.3是完成mips体系结构下的start.S函数 在理论课上我们可以知道，在将内核放置到内存中正确的位置上以后，操作系统就要找到程序入口start函数，之后进行一些初始化，包括初始化CP0寄存器，设置中断，还有设置栈指针等。本实验的start函数中，只是简单的初始化了CP0寄存器，并且设置栈指针。我闷很容易有一个想法，就是我们借助上一个题目的kernel.lds中的位置关系，找到栈指针的位置。但是这样做是不现实的，同时是错误的。因为栈的增长方向是向低地址增长，堆的增长方向是向高地址增长，因此这里要将栈指针放到0x84000000上 所以代码如下： 1234567891011121314151617181920#include &lt;asm/asm.h&gt;#include &lt;mmu.h&gt;.textEXPORT(_start)LEAF(_start).set at.set reorder /* disable interrupts */ mtc0 zero, CP0_STATUS /* hint: you can reference the memory layout in include/mmu.h */ /* set up the kernel stack */ /* Exercise 1.3: Your code here. (1/2) */ li sp,0x80400000 /* jump to mips_init */ /* Exercise 1.3: Your code here. (2/2) */ jal mips_initEND(_start) exercise1.4其实这道题没什么要说的，只要顺序判断对了，其实不是很难。整个的流程图放在这里 flowchart LR A(各个变量初始化) --> B(判断%或者\\0的位置) --> |如果是\\0|C(break) B --> |如果是%|D(fmt++) --> |如果开头是-|E(表示左对齐,fmt++) D --> |如果是0|F(则有前导零,fmt++) E --> G(读取width) F --> G --> |判断是否有l|H(表示是不是长整/浮点型) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273#include &lt;print.h&gt;/* forward declaration */static void print_char(fmt_callback_t, void *, char, int, int);static void print_str(fmt_callback_t, void *, const char *, int, int);static void print_num(fmt_callback_t, void *, unsigned long, int, int, int, int, char, int);void vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap) &#123; char c; const char *s; long num; int width; int long_flag; // output is long (rather than int) int neg_flag; // output is negative int ladjust; // output is left-aligned char padc; // padding char for (;;) &#123; num = 0,width = 0,long_flag = 0,neg_flag = 0,ladjust = 0,padc = 0; while((*fmt) != &#x27;%&#x27; &amp;&amp; (*fmt) != &#x27;\\0&#x27;) &#123; print_char(out,data,*fmt,1,0); fmt++; &#125; if((*fmt) == &#x27;\\0&#x27;) break; else if((*fmt) == &#x27;%&#x27;) fmt++; if((*fmt) == &#x27;-&#x27;) ladjust = 1,fmt++; else if((*fmt) == &#x27;0&#x27;) padc = &#x27;0&#x27;,fmt++; while(((*fmt) &gt;= &#x27;0&#x27; &amp;&amp; (*fmt) &lt;= &#x27;9&#x27;)) &#123; width = width * 10 + (*fmt) - &#x27;0&#x27;; fmt++; if(padc == 0) padc = &#x27; &#x27;; &#125; if((*fmt) == &#x27;l&#x27;) long_flag = 1,fmt++; /* scan for the next &#x27;%&#x27; */ /* Exercise 1.4: Your code here. (1/8) */ /* flush the string found so far */ /* Exercise 1.4: Your code here. (2/8) */ /* check &quot;are we hitting the end?&quot; */ /* Exercise 1.4: Your code here. (3/8) */ /* we found a &#x27;%&#x27; */ /* Exercise 1.4: Your code here. (4/8) */ /* check format flag */ /* Exercise 1.4: Your code here. (5/8) */ /* get width */ /* Exercise 1.4: Your code here. (6/8) */ /* check for long */ /* Exercise 1.4: Your code here. (7/8) */ neg_flag = 0; switch (*fmt) &#123; case &#x27;b&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; print_num(out, data, num, 2, 0, width, ladjust, padc, 0); break; case &#x27;d&#x27;: case &#x27;D&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; /* * Refer to other parts (case &#x27;b&#x27;, case &#x27;o&#x27;, etc.) and func &#x27;print_num&#x27; to * complete this part. Think the differences between case &#x27;d&#x27; and the * others. (hint: &#x27;neg_flag&#x27;). */ /* Exercise 1.4: Your code here. (8/8) */ if(num &lt; 0) num = -num,neg_flag = 1; print_num(out,data,num,10,neg_flag,width,ladjust,padc,0); break; case &#x27;o&#x27;: case &#x27;O&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; print_num(out, data, num, 8, 0, width, ladjust, padc, 0); break; case &#x27;u&#x27;: case &#x27;U&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; print_num(out, data, num, 10, 0, width, ladjust, padc, 0); break; case &#x27;x&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; print_num(out, data, num, 16, 0, width, ladjust, padc, 0); break; case &#x27;X&#x27;: if (long_flag) &#123; num = va_arg(ap, long int); &#125; else &#123; num = va_arg(ap, int); &#125; print_num(out, data, num, 16, 0, width, ladjust, padc, 1); break; case &#x27;c&#x27;: c = (char)va_arg(ap, int); print_char(out, data, c, width, ladjust); break; case &#x27;s&#x27;: s = (char *)va_arg(ap, char *); print_str(out, data, s, width, ladjust); break; case &#x27;\\0&#x27;: fmt--; break; default: /* output this char as it is */ out(data, fmt, 1); &#125; fmt++; &#125;&#125;/* --------------- local help functions --------------------- */void print_char(fmt_callback_t out, void *data, char c, int length, int ladjust) &#123; int i; if (length &lt; 1) &#123; length = 1; &#125; const char space = &#x27; &#x27;; if (ladjust) &#123; out(data, &amp;c, 1); for (i = 1; i &lt; length; i++) &#123; out(data, &amp;space, 1); &#125; &#125; else &#123; for (i = 0; i &lt; length - 1; i++) &#123; out(data, &amp;space, 1); &#125; out(data, &amp;c, 1); &#125;&#125;void print_str(fmt_callback_t out, void *data, const char *s, int length, int ladjust) &#123; int i; int len = 0; const char *s1 = s; while (*s1++) &#123; len++; &#125; if (length &lt; len) &#123; length = len; &#125; if (ladjust) &#123; out(data, s, len); for (i = len; i &lt; length; i++) &#123; out(data, &quot; &quot;, 1); &#125; &#125; else &#123; for (i = 0; i &lt; length - len; i++) &#123; out(data, &quot; &quot;, 1); &#125; out(data, s, len); &#125;&#125;void print_num(fmt_callback_t out, void *data, unsigned long u, int base, int neg_flag, int length, int ladjust, char padc, int upcase) &#123; /* algorithm : * 1. prints the number from left to right in reverse form. * 2. fill the remaining spaces with padc if length is longer than * the actual length * TRICKY : if left adjusted, no &quot;0&quot; padding. * if negtive, insert &quot;0&quot; padding between &quot;0&quot; and number. * 3. if (!ladjust) we reverse the whole string including paddings * 4. otherwise we only reverse the actual string representing the num. */ int actualLength = 0; char buf[length + 70]; char *p = buf; int i; do &#123; int tmp = u % base; if (tmp &lt;= 9) &#123; *p++ = &#x27;0&#x27; + tmp; &#125; else if (upcase) &#123; *p++ = &#x27;A&#x27; + tmp - 10; &#125; else &#123; *p++ = &#x27;a&#x27; + tmp - 10; &#125; u /= base; &#125; while (u != 0); if (neg_flag) &#123; *p++ = &#x27;-&#x27;; &#125; /* figure out actual length and adjust the maximum length */ actualLength = p - buf; if (length &lt; actualLength) &#123; length = actualLength; &#125; /* add padding */ if (ladjust) &#123; padc = &#x27; &#x27;; &#125; if (neg_flag &amp;&amp; !ladjust &amp;&amp; (padc == &#x27;0&#x27;)) &#123; for (i = actualLength - 1; i &lt; length - 1; i++) &#123; buf[i] = padc; &#125; buf[length - 1] = &#x27;-&#x27;; &#125; else &#123; for (i = actualLength; i &lt; length; i++) &#123; buf[i] = padc; &#125; &#125; /* prepare to reverse the string */ int begin = 0; int end; if (ladjust) &#123; end = actualLength - 1; &#125; else &#123; end = length - 1; &#125; /* adjust the string pointer */ while (end &gt; begin) &#123; char tmp = buf[begin]; buf[begin] = buf[end]; buf[end] = tmp; begin++; end--; &#125; out(data, buf, length);&#125; 结束语唔，第一次写博客，就随便写了，好多东西是比较随性的，看到哪里想到哪里的，如果有不正确和不准确不完善的地方，请各位大佬联系我。","categories":[],"tags":[]}],"categories":[],"tags":[]}